Spring事务管理器： 统一管理事务，JDBC,Hibernate,Mybatis一致的
是管理数据源的

一 事务传播 : 当在一个事务中，调用另一个事务时

Propagation.MANDATORY 。
	当前方法必须在已经定义的Transaction中运行，如果没有已定义的Transaction则抛出异常。
Propagation.NESTED 。
	如果没有已定义的Transaction，当前方法新开一个Transaction并在该Transaction中运行。如果存在已定义的Transaction，当前方法在嵌套事务(Nested Transaction)中运行 ― 嵌套事务中可以定义储存点，
	因此可以独立于外部的Transaction而进行rollback。
Propagation.NEVER 。
	当前方法不应在Transaction中运行，如果存在已经定义的Transaction则抛出异常。
Propagation.NOT_SUPPORTED 。
	当前方法不应在Transaction中运行，如果存在已经定义的Transaction，则该Transaction暂停(挂起)直至该方法运行完毕。
Propagation.REQUIRED 。
	默认值 。当前方法必须在Transaction中运行。如果存在已经定义的Transaction，则该方法在已定义的Transaction中运行；如果不存在已经定义的Transaction，则该方法新开一个Transaction并在其中运行。
Propagation.REQUIRES_NEW 。
	当前方法必须在新开的Transaction中运行。如果存在已经定义的Transaction，则该已定义的Transaction暂停直至新开的Transaction执行完毕。
Propagation.SUPPORTS 。
	当前方法不需要在Transaction中运行，但如果存在已经定义的Transaction，则该方法也可以在Transaction中正常执行。

具体事例
@Service("bookShopService")
public class BookShopServiceImpl implements BookShopService {
	@Autowired
	private BookShopDao bookShopDao;

	//添加事务注解
	//1.使用 propagation 指定事务的传播行为, 即当前的事务方法被另外一个事务方法调用时
	//如何使用事务, 默认取值为 REQUIRED, 即使用调用方法的事务
	//REQUIRES_NEW: 事务自己的事务, 调用的事务方法的事务被挂起.
	//2.使用 isolation 指定事务的隔离级别, 最常用的取值为 READ_COMMITTED
	//3.默认情况下 Spring 的声明式事务对所有的运行时异常进行回滚. 也可以通过对应的
	//属性进行设置. 通常情况下去默认值即可.
	//4.使用 readOnly 指定事务是否为只读. 表示这个事务只读取数据但不更新数据,
	//这样可以帮助数据库引擎优化事务. 若真的事一个只读取数据库值的方法, 应设置 readOnly=true
	//5.使用 timeout 指定强制回滚之前事务可以占用的时间.
//	@Transactional(propagation=Propagation.REQUIRES_NEW,
//			isolation=Isolation.READ_COMMITTED,
//			noRollbackFor={UserAccountException.class})
	@Transactional(propagation=Propagation.REQUIRES_NEW,
			isolation=Isolation.READ_COMMITTED,
			readOnly=false,
			timeout=3)
	@Override
	public void purchase(String username, String isbn) {
		try {
			Thread.sleep(5000);
		} catch (InterruptedException e) {}

		//1. 获取书的单价
		int price = bookShopDao.findBookPriceByIsbn(isbn);

		//2. 更新数的库存
		bookShopDao.updateBookStock(isbn);

		//3. 更新用户余额
		bookShopDao.updateUserAccount(username, price);
	}
}

二 事务隔离级别 : 在多个事务并发执行时，可能会脏读，不可重复读，幻读的问题

三 事务回滚 : 默认Spring的声明式事务对所有的运行时异常进行回滚
可以指定某些异常不进行回滚
如果设置readOnly只读属性，一般是查询操作，数据库可以做一个优化，不进行加锁

四 事务的执行时间: timeout
如果事务执行时间过长，回滚

五、使用时注意：
	在一个类中:
		方法A是不开启事务的
		方法B是开启事务
		方法A调用方法B时：A直接调用B时，不会开启事务
	解决办法：可以将B开启的事务，单独方法另一个类中。
		HibernateTransactionManager doBegin方法 进入事务
		JDBCTransaction : 是Hibernate事务的处理类，可以begin方法事务。在调用@Transaction方法前，会先进入这个方法。
		从事务管理器（TransactionInterceptor）可以跟踪代码，判断是否会创建事务。

六、在一个事务中要想事务回滚，必须抛出一个运行时异常。
	TransactionAspectSupport  类
		invokeWithinTransaction 方法






